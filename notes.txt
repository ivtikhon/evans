## This is my notebook
## I am writing my thoughts here the way they come to mind, i.e. not exactly ordered,
## but somewhat chronological
## (c) Igor Tikhonin, ivtikhon@gmail.com

### 2017 ###
# Hypothesis: if we define objects, a set of operations on objects, dependencies among
  objects, and some goal, this will be sufficient for a classical planner to build
  a plan to achieve the goal.

# Types of predicates
  - object state: object in some particular state, e.g. file system is created;
  - object dependencies: one object depends on another object, e.g. application
    requires file system;
  - (not sure) action trigger: order to perform some action, e.g. shut down instance

 # I need to find a method to define chains of dependencies, for example, if a file
  requires a directory to be stored in, the dependency file -> directory should
  imply that the destination directory exists, and its underlying file system exists
  and mounted, and volume where the file systems is located, exists too and attached.

# Maybe it is not enough just to define dependencies, but rather dependencies and
  desired states, for example, to install an application, a running instance of a certain
  type is required with a file system of a specified size mounted to a desired directory;
  and to start this application, another application is supposed to be running on
  another instance and respond to a relevant network port.

# There are dependencies that can be expressed on the type level, for example
  a file needs a directory for any operation, open/close/read/write, so every file
  existentially requires a directory; and there are dependencies that exist
  on the object level only, for example, to start the application A, we need the
  application B up and running.

# Dependencies exist in actions, for example, before copying a file, we
  need to make sure that the source/destination directory(ies) exist, so the
  action 'copy file' can be executed only after all dependencies are resolved.

# State can be simple, e.g. application is running, and it can be complex, e.g
  application is running on an instance. The same file can exists in multiple directories.
  The same application can be installed and started on multiple instances.

# Dependency can be "attached" to some state, e.g. in order to install an application
  a file is required and, say, some temporary storage space is necessary too. But,
  at the same time, to start this app, the installation file is not needed. So, the "installed"
  application state implies "exists" file state; and the "running" application state
  implies something else.

# Maybe I can define dependencies with desired states and attributes indicating if those
  dependencies were resolved, e.g. an object requires an instance "running":
  (requires-in-running ?inst1 - instance ?obj1 - object)
  (satisfied-in-running ?inst1 - instance ?obj1 - object)

# It is not clear how to express complex object state if I use predicates like this:
  (requires ?obj1 - object ?st1 - state ?obj2 - object ?st2 - state). Maybe I should
  use complex objects, e.g. instead of just declaring an application object which can exists
  on multiple instances, I can have many application_on_particular_instance objects. In
  this case, complex objects can have (many) simple states attached. This approach implies
  using (and operating with) unique objects.

# There are objects which can't just have simple state and which can't be split
  into multiple objects to become unique and hold a simple state; e.g. shared file
  system has to have the state 'mounted' to more than one instance; or file located
  in some repository can have the state 'copied' to many locations.
  Dependency chain:
      app1 - application - running --> requires --> ins1 - instance - running AND
          --> fs1 - local filesystem - mounted on inst1 - instance AND
          --> nfs1 - shared filesystem - mounted on inst1 - instance AND
          --> fl1 - file - accessible on url1 - url
  Complex state definition format:
    (has-state ?obj1 - object ?st1 - state ?obj2 - object) ;; obj1 has some state with regards to obj2

# Object A depends on object B: (requires ?a ?b); simple state dependency:
  state-chain (?a - object ?sta - state ?b - object ?stb - state)  <--- to get to the state STA
  object A requires object B to be in the state STB;

# Let's think about objects in general. Say, an application is an object. It could
  have states: running/not running, installed/not installed, deployed/not deployed
  (deployed might mean - copied, installed). These states work fine for one copy
  of the application. What if I want to install this application on more than one
  instance? What is the proper way to define complex application state? Should it
  have the state like 'installed on instance(s) A(B,C,D)'. Or I should define multiple
  copies of the same application to run on particular instances?

# So, I can define complex state like this: (has-state ?obj1 - object ?st1 - state ?obj2 - object),
  that is obj1 has some state with regards to obj2, e.g. application app1 has state
  installed_on instance inst1: (has-state app1 installed_on inst1); NFS share nfs1
  has state mounted_on instance inst1: (has-state nfs1 mounted_on inst1)

# I want to express this: if there is a dependency between two objects, such as,
  to achieve the state AA for the object A with regards to the object B, the object
  B has to be in his state BB with regards to any other objects C, the dependency
  has to be resolved first.

# Instance can have a simple state: running (not running or stopped), created,
  terminated. File can have only complex states: exists (does not exist) somewhere,
  created/copied somewhere, deleted from somewhere. So location is necessary part
  of the file's state.
  NFS share's state is attached to multiple instances.
  Volume can be attached to one instance only, i.e. volumes have simple states:
  created, attached (not attached)

# For each object I should create a list of dependencies. Dependencies that exists
  for all object of a class, should be defined on the class level and then clarified
  on the object level. For example, any file requires a directory, so the directory
  class should be listed as dependency for the file class.

# So, dependency patterns should be defined in classes; objects of classes should
  elaborate the patterns by assigning real objects to the pattern structures.

# There are implicit (internal, predefined) dependencies, e.g. an application can't
  be started unless it is installed, and there are explicit (external, yet to be
  defined) dependencies, e.g. the same application can't start until another
  application is running.

# Question: we define dependencies to build a system;  what if we already have the
  system built and now we want to modify it, e.g. there are two applications, one
  depends on another, and we want to stop one? Apparently the defined dependencies
  can be used in the reverse order, and the depended application should be stopped
  too. This actually means that dependencies have some direction (i.e. they are oriented),
  and the direction of each dependency defines "normal" (default, designed) behavior
  of the system.

# Dependencies might be strong, for example, if an application depends on
  several other applications, we may want to start all these applications first;
  and dependencies might be not that strong, for example, we don't want to
  stop all dependent applications, if this particular application is going down.

# To be able to define reverse conditions, we obviously have to define direct
  conditions and applicable actions, and actions applicable for reverse conditions.

# I want to define only high level dependencies. But I also want the tool to emphasize
  implicit (embedded, defined internally) dependencies.

# Maybe we can maintain two lists: list of states and list of external dependencies.

# There might be not only dependencies, but restrictions also, i.e. the overall model
  can be extended with restrictions.

### 2018 ###
# Current challenges:
  - YAML syntax: main structure and variables.
  - Planning fundamentals.
  - Use cases.

# Dependencies and restrictions reduce the state variables search space. So the right
  combination of restrictions increases overall performance.

# Domain and problem definition elements:
  - objects, arrays or lists of objects
  - types of objects or classes
  - relations or dependencies among classes and objects;
    - basically, if there are dependencies among classes, they should be inherited
      by objects as class representatives
    - objects extend the class level dependencies
    - relations among objects are expressed like this:
      * object A requires object B in state ST1 in order to get into state ST2 (which is expressed in action template)
      * dependencies either inherited from classes, or injected into action templates externally
  - set of object states
  - initial state of all objects
  - actions
    - actions have parameters and preconditions, of course
    - "injected" preconditions are predefined on the class level or defined for objects
    - action effect or result state defines the object state expressed in the form of relation
  - goal (desired state of the system)

# YAML description
variables:
  var1: [val1, val2, val3]
  var2: [val4, val5, val6]
init:
  var1: val1
  var2: val4
operators:
  move:
goal:

# class, state, attributes, class functions (interfaces);
  - all classes implicitly inherit the Plan class, where the functions setGoal
    createPlan are declared
  - simple way to run planning is to define some objects, add them to a list and
    run setGoal and createPlan

# important feature of the compiler should be to show all possible combinations of
  input parameters, so developers can evaluate all plans which can be generated
