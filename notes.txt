## This is my notebook
## I am writing my thoughts here the way they come to mind, i.e. not exactly ordered,
## but somewhat chronological
## (c) Igor Tikhonin, ivtikhon@gmail.com

# Types of predicates
  - object state: object in some particular state, e.g. file system is created;
  - object dependencies: one object depends on another object, e.g. application
    requires file system;
  - (not sure) action trigger: order to perform some action, e.g. shut down instance

# Dependency management
  Mantri http://mantrijs.com/     <--- take a look (not done yet...)

# Dependencies might be strong, for example, if an application depends on
  several other applications, we may want to start all these applications first;
  and dependencies might be not that strong, for example, we don't want to
  stop all dependent applications, if this particular application is going down.

 # I need to find a method to define chains of dependencies, for example, if a file
  requires a directory to be stored in, the dependency file -> directory should
  imply that the destination directory exists, and its underlying file system exists
  and mounted, and volume where the file systems is located, exists too and attached.

# Maybe it is not enough just to define dependencies, but rather dependencies and
  desired states, for example, to install an application, a running instance of a certain
  type is required with a file system of a specified size mounted to a desired directory;
  and to start this application, another application is supposed to be running on
  another instance and respond to a relevant network port.

# There are dependencies that can be expressed on the type level, for example
  a file needs a directory for any operation, open/close/read/write, so every file
  existentially requires a directory; and there are dependencies that exist
  on the object level only, for example, to start the application A, we need the
  application B up and running.

# Dependencies are executed in actions, for example, before copying a file, we
  need to make sure that the source/destination directory(ies) exist, so the
  action 'copy file' can be executed only after all dependencies are resolved. Thus,
  here is a question: can we have an action to resolve dependencies?

# Basically, every action should have dependency check as precondition, for example
  application can't start until all applications it depends on have started, and
  all file systems are created and mounted, and necessary files have copied; i.e.
  until all dependencies have their status changed.

# State can be simple, e.g. application is running, and it can be complex, e.g
  application is running on an instance. The same file can exists in multiple directories.
  The same application can be installed and started on multiple instances.

# Dependency can be "attached" to some state, e.g. in order to install an application
  a file is required and, say, some temporary storage space is necessary too. But,
  at the same time, to start this app, the installation file is not needed. So, the "installed"
  application state implies "exists" file state; and the "running" application state
  implies something else.

# Maybe I can define dependencies with desired states and attributes indicating if those
  dependencies were resolved, e.g. an object requires an instance "running":
  (requires-in-running ?inst1 - instance ?obj1 - object)
  (satisfied-in-running ?inst1 - instance ?obj1 - object)

# It is not clear how to express complex object state if I use predicates like this:
  (requires ?obj1 - object ?st1 - state ?obj2 - object ?st2 - state). Maybe I should
  use complex objects, e.g. instead of just declaring an application object which can exists
  on multiple instances, I can have many application_on_particular_instance objects. In
  this case, complex objects can have (many) simple states attached. This approach implies
  using (and operating with) unique objects.

# There are objects which can't just have simple state and which can't be split into multiple objects
  to become unique and hold a simple state; e.g. shared file system has to have the state 'mounted'
  to more than one instance; or file located in some repository can have the state 'copied' to many
  locations.
  Dependency chain:
      app1 - application - running --> requires --> ins1 - instance - running AND
          --> fs1 - local filesystem - mounted on inst1 - instance AND
          --> nfs1 - shared filesystem - mounted on inst1 - instance AND
          --> fl1 - file - accessible on url1 - url
  Complex state definition format:
    (has-state ?obj1 - object ?st1 - state ?obj2 - object) ;; obj1 has some state with regards to obj2

# What if I add dependent objects to actions as parameters?

# Object A depends on object B: (requires ?a ?b); simple state dependency:
  state-chain (?a - object ?sta - state ?b - object ?stb - state)  <--- to get to the state STA
  object A requires object B to be in the state STB;

# Let's think about objects in general. Say, an application is an object. It could have states: running/not running,
  installed/not installed, deployed/not deployed  (deployed might mean - copied, installed). These states work fine
  for one copy of the application. What if I want to install this application on more than one instance?
  What is the proper way to define complex application state? Should it have the state like
  'installed on instance(s) A(B,C,D)'. Or I should define multiple copies of the same application to
  run on particular instances?

# So, I can define complex state like this: (has-state ?obj1 - object ?st1 - state ?obj2 - object), that is
  obj1 has some state with regards to obj2, e.g. application app1 has state installed_on instance inst1:
  (has-state app1 installed_on inst1); NFS share nfs1 has state mounted_on instance inst1:
  (has-state nfs1 mounted_on inst1)
