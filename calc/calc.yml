---
# Simple calculator in Evans YAML
# Developed by Igor Tikhonin in 2018
#
# Model description:
# when mouse button is clicked and the mouse pointer
# coordinates corresponds to any of the calc buttons,
# or if a keyboard key is pressed corresponging to
# any calc button, then:
#
# 1) when a digit or digital point button is pressed
# its value is pushed to stack and display is regreshed;
#
# 2) when an operation button (+,-,/,*) is pressed, then:
# - if the early entered operation value is empty
#   store the operation to the early entered operation variable;
#   else, do the same as for '=' sign and then store the operation
#   to the early entered operation variable;
# 3) when the '=' sign is pressed,
#   execute the early entered operation with stack and register,
#   store the result to register and copy it to stack; clear
#   early entered operation

classes:
  Stack:
    data: # in Evans, user data along with data methods coexists
          # with state variables and their respective operators;
          # data variables are used to initialize the state variables before planning;
          # on the other hand, data variables themselves are modified from planning
          # operators during the plan execution phase;
      vars:
        s: List
      methods:  # the actual methods should be written in some language (e.g. Python or JS) for now;
                # after plan is created, the interpreter will generate code and then execute it;
                # later, when the Evans syntax is designed, the translation phase won't be necessary;
                # TODO: think about calling data methods implicitly from operators if names and parameters match;
        pushKey:
          parameters:
            k: Key # can be data or hybrid types
          body: |
            s.append(k.getValue())

        pushReg:
          parameters:
            a: Alu
          body: |
            s.append(str(a.getReg()).split())

        getValue:
          body: |
            return ''.join(s)

        clean:
          body: |
            s.clear()
    state:
      vars:
        last_key: ['digit', 'point']  # state variable with explisitly listed values (inline enum);
                                      # it is not clear what should be the default value for enum;
                                      # TODO: read again what Helmert and Hoffmann say about FDR state variables
        dec_point: Boolean # False is the default value for Boolean type
        changed: Boolean
        tobe_cleaned: Boolean
      predicates: # predicates seem to be useful for simple state inquires
                  # TODO: predicates in PDDL can have multiple arguments: think about how to implement it here
        isLastKeyDigit: last_key == 'digit' # Logical expressions: any non-zero value is true; zero is false;
                                            # supported operators: '==', '!=', and, or, not
        isLastKeyPoint: last_key == 'point'
        isDecPoint: dec_point
      operators: # actions in PDDL terms
        push:
          parameters: # global variables are not supported, i.e. the variable scope is limitied
                      # by parameters and variables defined in classes;
                      # TODO: it is not clear how to implement PDDL operators 'forall' and 'exists';
                      # think about using lists in state operators
            k: Key # can be state or hybrid types
          when:
            - not changed
            - not k.processed
            - k.isDigit or (k.isPoint and not dec_point)
            - not tobe_cleaned
          effect:
            - changed = True
            - k.processed = True
            - if: k.isPoint
              then:
                - last_key = 'point'
                - dec_point = True
              else: last_key = 'digit'
          exec:
            pushKey: k  # data methods are called from here;
                        # assignments, conditionals, loops, etc. are not supported for now;

        clean:
          parameters:
            k: Key
          when:
            - not k.processed
            - k.isDigit or k.isPoint
            - tobe_cleaned
          effect:
            - tobe_cleaned = False
            - dec_point = False
            - last_key = 'undef'
          exec:
            clean:  # data method call with no parameters

        stack_from_register:
          parameters:
            k: Key
            a: Alu
          when:
            - a.isOpExecuted
            - k.isOp or k.isEq
            - not k.processed
          effect:
            - k.processed = True
            - changed = True
            - a.reg_stored = False
            - tobe_cleaned = True
          exec:
            clean:
            pushReg: a

  Alu:
    data:
      vars:
        reg: Float
        op: Char
      methods:
        storeReg:
          parameters:
            s: Stack
          body: |
            reg = float(s.getValue())
        storeOp:
          parameters:
            k: Key
          body: |
            op = k.getValue()
        execOp:
          parameters:
            s: Stack
          body: |
            st1 = float(s.getValue())
            if op == '+':
              reg = st1 + reg
            elif op == '-':
              reg = st1 + reg
            elif op == '*':
              reg = st1 * reg
            elif op == '/':
              reg = st1 / reg
    state:
      vars:
        reg_stored: Boolean
        op_executed: Boolean
        op_stored: Boolean
      predicates:
        isOpExecuted: op_executed == True
        isOpStored: op_stored == True
        isRegStored: reg_stored == True
      operators:
        stack_to_register:
          parameters:
            k: Key
            s: Stack
          when:
            - not k.processed
            - k.isOp
            - not reg_stored
            - isOpStored
          effect:
            - reg_stored = True
            - k.processed = True
            - s.tobe_cleaned = True
          exec:
            storeReg: s

        store_op:
          parameters:
            k: Key
          when:
            - not isOpStored
            - k.isOp
            - not reg_stored
            - not k.processed
          effect: op_stored = True
          exec:
            storeOp: k

        exec_op:
          parameters:
            k: Key
            s: Stack
          when:
            - isOpStored
            - k.isOp or k.isEq
            - isRegStored
            - not k.processed
            - not isOpExecuted
          effect:
            - op_executed = True
            - if: k.isEq
              then: op_stored = False
          exec:
            execOp: s

  Key:
    data:
      vars:
        k: Char
      methods:
        getValue:
          body: |
            return k
    state:
      vars:
        k_val: ['digit', 'point', 'op', 'eq', 'clear', 'erase']
        processed: Boolean
      predicates:
        isOp: k_val == 'op'
        isDigit: k_val == 'digit'
        isPoint: k_val == 'point'
        isEq: k_val == 'eq'
        isClear: k_val == 'clear'
        isErase: k_val == 'erase'
      operators:
        no_op:
          parameters:
            s: Stack
          when:
            - not processed
            - isPoint
            - s.isDecPoint
          effect: processed
