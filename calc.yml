---
# when mouse button is clicked and the mouse pointer
# coordinates corresponds to any of the calc buttons,
# or if a keyboard key is pressed corresponging to
# any calc button, then:
#
# 1) when a digit or digital point button is pressed
# its value is pushed to stack and display is regreshed;
#
# 2) when an operation button (+,-,/,*) is pressed, then:
# - if the early entered operation value is empty
#   store the operation to the early entered operation variable;
#   else, do the same as for '=' sign and then store the operation
#   to the early entered operation variable;
# 3) when the '=' sign is pressed,
#   execute the early entered operation with stack and register,
#   store the result to register and copy it to stack; clear
#   early entered operation

classes:
  Stack:
    data: # data and state variables have to be separated
          # I can't think of any better implementation model for now (as of May, 2018);
          # so, we have hybrid classes, where user data along with data methods  coexists
          # with state variables and their respective operators;
          # data variables are used to initialize the state variables before planning;
          # on the other hand, data variables themselves are modified from planning
          # operators during the plan execution phase;
      vars:
        dict: List
      methods:  # the actual methods should be written in some language (e.g. Python or JS) for now;
                # after plan is created, the interpreter will generate code and then execute it;
                # later, when the Evans syntax is designed, the translation phase won't be necessary;
                # TODO: think about calling data methods implicitly from operators if names and parameters match;
        push:
          parameters:
            k: Key # can be data or hybrid types
          body: |
            dict.append(k.getValue())

        read:
          body: dict.toString()

        clean:
          body: dict.erase()
    state:
      vars:
        last_key: ['digit', 'point', 'undef'] # state variable with explisitly listed values (inline enum)
        dec_point: Boolean
        changed: Boolean
        tobe_cleaned: Boolean
      predicates: # predicates seem to be useful for simple state inquires
        isLastKeyDigit: (last_key == 'digit') # TODO: find a template engine to work with logical expressions
        isLastKeyPoint: (last_key == 'point')
      operators: # actions in PDDL terms
        push:
          parameters: # we don't use global variables, so the variable scope is limitied
                      # by parameters and variables defined in classes;
                      # there are no plans to support PDDL operators 'forall' and 'exists' for now;
            k: Key # can be state or hybrid types
          when:
            - not changed
            - not k.processed
            - k.isDigit or k.isPoint
            - not tobe_cleaned
          effect:
            - changed = True
            - k.processed = True
            - if: k.isPoint
              then:
                - last_key = 'point'
                - dec_point = True
              else:
                  last_key = 'digit'
          exec: |
            push(k)  # data processing is done here; the exec section of operator has direct access to data methods

        stack_to_register:
          parameters:
            k: Key
            a: Alu
          when:
            - not k.processed
            - k.isOp
            - not a.reg_stored
            - a.op_stored
          effect:
            - a.reg_stored = True
            - k.processed = True
            - tobe_cleaned = True
          exec: |
            a.store(read.toInt())

        clean:
          parameters:
            k: Key
          when:
            - not k.processed
            - k.isDigit or k.isPoint
            - tobe_cleaned
          effect:
            - tobe_cleaned = False
            - dec_point = False
            - last_key = 'undef'
          exec: |
            erase()
