---
# when mouse button is clicked and the mouse pointer
# coordinates corresponds to any of the calc buttons,
# or if a keyboard key is pressed corresponging to
# any calc button, then:
#
# 1) when a digit or digital point button is pressed
# its value is pushed to stack and display is regreshed;
#
# 2) when an operation button (+,-,/,*) is pressed, then:
# - if the early entered operation value is empty
#   store the operation to the early entered operation variable;
#   else, do the same as for '=' sign and then store the operation
#   to the early entered operation variable;
# 3) when the '=' sign is pressed,
#   execute the early entered operation with stack and register,
#   store the result to register and copy it to stack; clear
#   early entered operation

classes:
  Stack:
    data: # data and state variables have are separate for now;
          # so, there are hybrid classes, where user data along with data methods coexists
          # with state variables and their respective operators;
          # data variables are used to initialize the state variables before planning;
          # on the other hand, data variables themselves are modified from planning
          # operators during the plan execution phase;
      vars:
        s: List
      methods:  # the actual methods should be written in some language (e.g. Python or JS) for now;
                # after plan is created, the interpreter will generate code and then execute it;
                # later, when the Evans syntax is designed, the translation phase won't be necessary;
                # TODO: think about calling data methods implicitly from operators if names and parameters match;
        pushKey:
          parameters:
            k: Key # can be data or hybrid types
          body: |
            s.append(k.getValue())

        pushReg:
          parameters:
            a: Alu
          body: |
            s.append(a.getReg().toStr().toList()) # the syntax is not real for now;
                                                  # I'll get back to this on the later stages

        getValue:
          body: s.toString()

        clean:
          body: s.erase()
    state:
      vars:
        last_key: ['digit', 'point', 'undef'] # state variable with explisitly listed values (inline enum);
                                              # 'undef' is the default value for inline enum
        dec_point: Boolean # False is the default value for Boolean type
        changed: Boolean
        tobe_cleaned: Boolean
      predicates: # predicates seem to be useful for simple state inquires
        isLastKeyDigit: last_key == 'digit' # TODO: find a template engine to work with logical expressions
        isLastKeyPoint: last_key == 'point'
        isDecPoint: dec_point == True
      operators: # actions in PDDL terms
        push:
          parameters: # global variables are not supported, i.e. the variable scope is limitied
                      # by parameters and variables defined in classes;
                      # it is not clear how to implement PDDL operators 'forall' and 'exists';
                      # TODO: think about using lists in state operators
            k: Key # can be state or hybrid types
          when:
            - not changed
            - not k.processed
            - k.isDigit or (k.isPoint and not dec_point)
            - not tobe_cleaned
          effect:
            - changed = True
            - k.processed = True
            - if: k.isPoint
              then:
                - last_key = 'point'
                - dec_point = True
              else: last_key = 'digit'
          exec:
            pushKey: k  # data methods can be called from here;
                        # assignments, conditionals, loops, etc. are not supported for now;

        clean:
          parameters:
            k: Key
          when:
            - not k.processed
            - k.isDigit or k.isPoint
            - tobe_cleaned
          effect:
            - tobe_cleaned = False
            - dec_point = False
            - last_key = 'undef'
          exec:
            clean:  # data method call with no parameters

        stack_from_register:
          parameters:
            k: Key
            a: Alu
          when:
            - a.isOpExecuted
            - k.isOp or k.isEq
            - not k.processed
          effect:
            - k.processed = True
            - changed = True
            - a.reg_stored = False
            - tobe_cleaned = True
          exec:
            clean:
            pushReg: a

  Alu:
    data:
      vars:
        reg: Float
        op: Char
      methods:
        storeReg:
          parameters:
            s: Stack
          body: |
            reg = s.getValue().toFloat()
        storeOp:
          parameters:
            k: Key
          body: |
            op = k.getValue()
        execOp:
          parameters:
            s: Stack
          body: |
            st1 = s.getValue().toFloat()
            if op == '+':
              reg = st1 + reg
            elif op == '-':
              reg = st1 + reg
            elif op == '*':
              reg = st1 * reg
            elif op == '/':
              reg = st1 / reg
    state:
      vars:
        reg_stored: Boolean
        op_executed: Boolean
        op_stored: Boolean
      predicates:
        isOpExecuted: op_executed == True
        isOpStored: op_stored == True
        isRegStored: reg_stored == True
      operators:
        stack_to_register:
          parameters:
            k: Key
            s: Stack
          when:
            - not k.processed
            - k.isOp
            - not reg_stored
            - isOpStored
          effect:
            - reg_stored = True
            - k.processed = True
            - s.tobe_cleaned = True
          exec:
            storeReg: s

        store_op:
          parameters:
            k: Key
          when:
            - not isOpStored
            - k.isOp
            - not reg_stored
            - not k.processed
          effect: op_stored = True
          exec:
            storeOp: k

        exec_op:
          parameters:
            k: Key
            s: Stack
          when:
            - isOpStored
            - k.isOp or k.isEq
            - isRegStored
            - not k.processed
            - not isOpExecuted
          effect:
            - op_executed = True
            - if: k.isEq
              then: op_stored = False
          exec:
            execOp: s

  Key:
    data:
      vars:
        k: Char
      methods:
    state:
      vars:
        k_val: ['digit', 'point', 'op', 'eq', 'clear', 'erase', 'undef']
        processed: Boolean
      predicates:
        isOp: k_val == 'op'
        isDigit: k_val == 'digit'
        isPoint: k_val == 'point'
        isEq: k_val == 'eq'
        isClear: k_val == 'clear'
        isErase: k_val == 'erase'
      operators:
        no_op:
          parameters:
            s: Stack
          when:
            - not processed
            - isPoint
            - s.isDecPoint
          effect: processed
