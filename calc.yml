---
# when mouse button is clicked and the mouse pointer
# coordinates corresponds to any of the calc buttons,
# or if a keyboard key is pressed corresponging to
# any calc button, then:
#
# 1) when a digit or digital point button is pressed
# its value is pushed to stack and display is regreshed;
#
# 2) when an operation button (+,-,/,*) is pressed, then:
# - if the early entered operation value is empty
#   store the operation to the early entered operation variable;
#   else, do the same as for '=' sign and then store the operation
#   to the early entered operation variable;
# 3) when the '=' sign is pressed,
#   execute the early entered operation with stack and register,
#   store the result to register and copy it to stack; clear
#   early entered operation

classes:
  stack:
    data: # data and state variables have to be separated
          # I can't think of any better implementation model for now (as of May, 2018);
          # so, we have hybrid classes, where user data along with data methods  coexists
          # with state variables and their respective operators;
          # data variables are used to initialize the state variables before planning;
          # on the other hand, data variables themselves are modified from planning
          # operators during the plan execution phase;
      vars:
        dict: dictionary
      methods:  # the actual methods should be written in Python for now;
                # after plan is created, the interpreter will generate code and then execute it;
                # later, when the Evans syntax is designed, the translation phase won't be necessary;
        push:
          parameters:
            k: key
          body: |
            dict.append(k.getValue())
    state:
      vars:
        last_key: ['digit', 'point'] # FDR state variable with explisitly listed values
        dec_point: boolean # boolean FDR state variable
        changed: boolean
        tobe_cleaned: boolean
      predicates: # predicates seem to be useful for simple state inquires
        isLastKeyDigit: last_key == 'digit' # TODO: find a template engine to work with logical expressions
        isLastKeyPoint: last_key == 'point'
      operators: # actions in PDDL terms
        push:
          parameters:
            k: key
          when:
            - not k.processed
            - k.isDigit or k.isPoint
            - not changed
            - not tobe_cleaned
          effect:
            - changed = True
            - k.processed = True
            - if k.isPoint then last_key = 'point' and dec_point = True else last_key = 'digit'
          execute: push(k)  # data processing is done here; the execute section of operator has direct access to data methods
        read:
          # convert from string to float and return
        store:
          # convert from float and store to array as string
