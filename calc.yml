---
# when mouse button is clicked and the mouse pointer
# coordinates corresponds to any of the calc buttons,
# or if a keyboard key is pressed corresponging to
# any calc button, then:
#
# 1) when a digit or digital point button is pressed
# its value is pushed to stack and display is regreshed;
#
# 2) when an operation button (+,-,/,*) is pressed, then:
# - if the early entered operation value is empty
#   store the operation to the early entered operation variable;
#   else, do the same as for '=' sign and then store the operation
#   to the early entered operation variable;
# 3) when the '=' sign is pressed,
#   execute the early entered operation with stack and register,
#   store the result to register and copy it to stack; clear
#   early entered operation

classes:
  stack:
    data: # data and state variables have to be separated
          # I can't think of any better implementation model for now (as of May, 2018);
          # so, we have hybrid classes, where user data along with data methods  coexists
          # with state variables with their respective operators;
          # state variables are initialized as usual before the planning starts,
          # i.e. data variables are used to initialize the state variables before planning;
          # on the other hand, data variables themselves are modified from planning
          # operators during plan execution phase, i.e. after plan has been created;
      vars:
        dict: dictionary
      methods:
        push:
          parameters:
            k: key
          body:
            dict.append(k.value) # TODO find an appropriate syntax to call data functions
    fdr:
      vars: # FDR state variables
        last_key: ['digit', 'point'] # TODO find an appropriate syntax for FDR variables
        dec_point: boolean
        changed: boolean
        tobe_cleaned: boolean
      predicates: # predicates seem to be useful for simple state inquires
        isLastKeyDigit: last_key == 'digit'
        isLastKeyPoint: last_key == 'point'
      operators: # actions in PDDL terms
        push:
          parameters:
            k: key
          when:
            - not k.processed
            - k.isDigit or k.isPoint
            - not changed
            - not tobe_cleaned
          effect:
            - changed = True # TODO find an appropriate syntax for variable assignment
            - k.processed = True
            - if k.isPoint then last_key = 'point' and dec_point = True else last_key = 'digit'
          execute: data.push(k)  # data processing is done here; maybe this section of fdr operator should have exclusive access to data section
        read:
          # convert from string to float and return
        store:
          # convert from float and store to array as string
