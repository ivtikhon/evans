---
# when mouse button is clicked and the mouse pointer
# coordinates corresponds to any of the calc buttons,
# or if a keyboard key is pressed corresponging to
# any calc button, then:
#
# when a digit button is pressed
# its value is pushed to the current stack (one of two)
# and also showed in the right position of the display
# (or the current stack content is simply showed every
# time when a digit button is pressed)
#
# when an operation button (+,-,/,*) is pressed, then:
# - if the current operation value is not empty,
#   execute the early entered operation, store the result
#   to the current stack and display the result
# - switch the current stack to another one
#
# when the equal sign is pressed,
# execute the current operation, store the result to
# the current stack, swithch the stack

# attributes are defined in classes
# and these attributes correspond to FDR state variables

# probably, I should distinguish between data processing functions and planning operations
# assuming the latter participate in planning
# it is not clear, though how to "call" data functions
# the planning operators should be called by planner by "implicitly" declaring
# the planner class along with its (planning) methods
# maybe I should have a common space visible for all objects
# participating in planning, so operators can be triggered by assigning
# corresponging values to triggering variables
# this also related to dependecy injection
# in other words for all planning events there should be common space where all operators and
# their respective preconditions are visible
#
# or maybe this should be just list of objects with their (planning) operators
# and each object has references to related data in other objects
#
# what if I define topics and objects will sunbscribe to topics and listen to events
# or maybe some kind of integration classes can be defined
# anyway, I need to find a way to trigger planning operators

classes:
  display:
    attributes:
      position: 0
    operations:
      draw:
        # draw its frame and also content of stack

  stack:
    data:
      array: dictionary
    functions:
      append:
        parameters:
          k: key
        body:
          array.append(k.getValue()) # TODO find an appropriate syntax to call data functions
    attributes:
      last_key: [digit, point]  # TODO find an appropriate syntax to access states
      dec_point: boolean
      changed: boolean
      tobe_cleaned: boolean
    operators:
      push:
        parameters:
          k: key
        when:
          - not k.processed
          - k.isDigit or k.isPoints
          - not changed
          - not tobe_cleaned
        effect:
          - changed
          - k.processed
          - if k.isPoint -> last_key.point and dec_point else -> last_key.digit
        execute: append(k)
      pop:
        when:
          # erase button is pressed
      read:
          # convert from string to float and return
      store:
          # convert from float and store to array as string
