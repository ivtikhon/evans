# Simple calculator in Evans
# Developed by Igor Tikhonin in 2019
#
# Model description:
# =================
# Calculator consists of the following parts:
# - stack,
# - arithmetic unit (AU),
# - display,
# - keyboard.
# Operations:
# 1) when a digit is entered, its value is pushed to the stack and displayed;
# 2) when an operation (+,-,/,*) is entered, then:
#    operation is stored to the AU, or, if the AU store is not empty,
#    the early entered operation is executed the same way as if the equal sign
#    is entered; then the current operation is stored to the AU;
# 3) when the equal sign ('=') sign is entered, the operation stored in AU
#    is executed, using the stack and the register values as operands, and
#    the result stored to register; the result is also copied to the stack
#    and displayed; the AU store is cleared.


class stack { # attributes and state variables share the same namespace within class
  attr:
    list s;
  state:
    list last_key = ('digit', 'point'); # 'undef' is the default value, unless specified
    bool dec_point, changed = false;
    bool tobe_cleaned; # uninitialized state variable; bool variables are initialized to false by default

  func:
    stack() {  # constructor has full access to all attributes
      s.append('0');
      last_key = 'digit';
      tobe_cleaned = false;  # false is the default value, i.e. initialization here is redundant
    }

    push_key(key k) { # functions have access to attributes, but not to the state variables
      s.append(k.get_value());
    }

    push_reg(alu a) {
      s.extend(str(a.get_reg()).split());
    }

    getValue():str { ret ''.join(s); }

    clean(){ s.clear(); }

  pred:
    is_last_key_digit(){ ret (last_key == 'digit'); } # predicates have read-only access to state variables; predicates always return bool
    is_last_key_point(){ ret (last_key == 'point'); }
    is_dec_point(){ ret (dec_point); }

  oper:
    push (key k) {
      when:
        not changed and
        not k.processed and
        (k.is_digit or (k.k_val == 'point' and not dec_point))
      eff:
        changed = true;
        k.processed = true;
        if (k.is_point) {
          last_key = 'point';
          dec_point = true;
        } else {
          last_key = 'digit';
        }
      exec:
        push_key(k);
    }

    clean(key k){
      when:
        not k.processed and
        (k.is_digit or k.is_point) and
        tobe_cleaned
      eff:
        tobe_cleaned = false;
        dec_point = false;
        last_key = 'digit';
      exec:
        clean();
    }

    copy_from_register(key k, alu a){
      when:
        a.is_op_executed and
        (k.is_op or k.is_eq) and
        not k.processed
      eff:
        if (k.is_eq) {
          k.processed = true;
          changed = true;
          a.reg_stored = false;
          tobe_cleaned = true;
          a.op_executed = false;
        }
      exec:
        clean();
        push_reg(a);
    }
}

class alu {
  attr:
    float reg = 0.0;
    str op = '';

  state:
    bool reg_stored;
    bool op_executed;
    bool op_stored;

  func:
    getReg ():float {ret reg;}

    storeReg (stack s){
        reg = float(s.getValue());
    }

    storeOp(key k) {
        op = k.getValue();
    }

    execOp(stack s) {
      float st1 = float(s.getValue());
      if (op == '+'){
        reg += st1;
      } elif (op == '-'){
        reg -= st1;
      } elif (op == '*'){
        reg *= st1;
      } elif (op == '/') {
        reg /= st1;
      }
    }

  pred:
    isOpExecuted() {ret (op_executed == True);}
    isOpStored() {ret (op_stored == True);}
    isRegStored() {ret (reg_stored == True);}

  oper:
    stack_to_register(key k, stack s){
      when:
        not k.processed and
        k.isOp and
        not reg_stored and
        isOpStored
      eff:
        reg_stored = true;
        k.processed = true;
        s.tobe_cleaned = true;
      exec:
        s.storeReg();
    }

    store_op (key k){
      when:
        not isOpStored and
        k.isOp and
        not reg_stored and
        not k.processed
      eff:
        op_stored = true;
      exec:
        toreOp();
    }

    exec_op (key k, stack s) {
      when:
        isOpStored and
        (k.isOp or k.isEq) and
        isRegStored and
        not k.processed and
        not isOpExecuted
      eff:
        op_executed = true;
        if(k.isEq or k.isOp) {
          op_stored = false;
        }
      exec:
        s.execOp();
    }
}

class key {
  attr:
    str k = '';

  state:
    list k_val = ('digit', 'point', 'op', 'eq', 'clear', 'erase');
    bool processed;

  func:
    key(){
      k_val = 'digit';
    }

    getValue():str { ret k;}

    setValue(str val) { k = val;}

  pred:
    isOp() {ret (k_val == 'op');}
    isDigit() {ret (k_val == 'digit');}
    isPoint() {ret (k_val == 'point');}
    isEq() {ret (k_val == 'eq');}
    isClear() {ret (k_val == 'clear');}
    isErase() {ret (k_val == 'erase');}

  oper:
    no_op (stack s){
      when:
        not processed and
        isPoint and
        s.isDecPoint
      eff:
        processed = true;
    }
}

class display {
  state:
    bool updated;

  func:
    showStack(stack s){ print(s.getValue());}

  oper:
    show_stack(stack s, key k) {
      when:
        not updated and
        k.processed and
        s.changed

      eff:
        updated = true;
        s.changed = false;

      exec:
        s.showStack();
    }
}
