#
# Simple calculator in Evans
# Copyright (c) 2019 Igor Tikhonin
#
# Model description:
# =================
# Calculator consists of the following parts:
# - stack,
# - arithmetic unit (AU),
# - display,
# - keyboard.
# Operations:
# 1) when a digit is entered, its value is pushed to the stack and displayed;
# 2) when an operation (+,-,/,*) is entered, then:
#    operation is stored to the AU, or, if the AU store is not empty,
#    the early entered operation is executed the same way as if the equal sign
#    is entered; then the current operation is stored to the AU;
# 3) when the equal sign ('=') sign is entered, the operation stored in AU
#    is executed, using the stack and the register values as operands, and
#    the result stored to register; the result is also copied to the stack
#    and displayed; the AU store is cleared.


class stack { # attributes and state variables share the same namespace within class
  attr:
    list s; # uninitialized list is empty
  state:
    dom last_key = ('digit', 'point'); # 'undef' is the default value of enum variables
    bool dec_point, changed = false;
    bool tobe_cleaned; # uninitialized state variable; bool variables are initialized to false by default

  init:
    stack() {  # constructor has full access to all attributes
      s.append('0');
      last_key = 'digit';
      tobe_cleaned = false;  # false is the default value, i.e. initialization here is redundant
    }

  func:
    push_key(key k) { # functions have access to attributes, but not to the state variables
      s.append(k.get_value());
    }

    push_reg(alu a) {
      s.extend(str(a.get_reg()).split());
    }

    get_value():str { ret ''.join(s); }

    clean(){ s.clear(); }

  pred:
    is_last_key_digit(){ ret (last_key == 'digit'); } # predicates have read-only access to state variables; predicates always return bool
    is_last_key_point(){ ret (last_key == 'point'); }
    is_dec_point(){ ret dec_point; }

  oper:
    push (key k) {
      when: # precondition and effect sections have access to state variables, and no access to attributes
        not changed and
        not k.processed and
        (k.is_digit() or (k.k_val == 'point' and not dec_point))
      eff:
        changed = true;
        k.processed = true;
        if (k.is_point()) {
          last_key = 'point';
          dec_point = true;
        } else {
          last_key = 'digit';
        }
      exec: # exec has full access to attributes and read-only access to state variables
        push_key(k);
    }

    clean(key k){
      when:
        not k.processed and
        (k.is_digit() or k.is_point()) and
        tobe_cleaned
      eff:
        tobe_cleaned = false;
        dec_point = false;
        last_key = 'digit';
      exec:
        clean();
    }

    copy_from_register(key k, alu a){
      when:
        a.is_op_executed and
        (k.is_op() or k.is_eq()) and
        not k.processed
      eff:
        if (k.is_eq()) {
          k.processed = true;
          changed = true;
          a.reg_stored = false;
          tobe_cleaned = true;
          a.op_executed = false;
        }
      exec:
        clean();
        push_reg(a);
    }
}

class alu {
  attr:
    float reg = 0.0;
    str op = '';

  state:
    bool reg_stored, op_executed, op_stored;

  func:
    get_reg ():float {ret reg;}

    store_reg (stack s){
        reg = float(s.get_value());
    }

    store_op(key k) {
        op = k.get_value();
    }

    exec_op(stack s) {
      float st1 = float(s.get_value());
      if (op == '+'){
        reg += st1;
      } elif (op == '-'){
        reg -= st1;
      } elif (op == '*'){
        reg *= st1;
      } elif (op == '/') {
        reg /= st1;
      }
    }

  pred:
    is_op_executed() {ret op_executed;}
    is_op_stored() {ret op_stored;}
    is_reg_stored() {ret reg_stored;}

  oper:
    stack_to_register(key k, stack s){
      when:
        not k.processed and
        k.is_op() and
        not reg_stored and
        is_op_stored()
      eff:
        reg_stored = true;
        k.processed = true;
        s.tobe_cleaned = true;
      exec:
        s.store_reg();
    }

    store_op (key k){
      when:
        not is_op_stored() and
        k.is_op() and
        not reg_stored and
        not k.processed
      eff:
        op_stored = true;
      exec:
        toreOp();
    }

    exec_op (key k, stack s) {
      when:
        is_op_stored() and
        (k.is_op() or k.is_eq()) and
        is_reg_stored() and
        not k.processed and
        not is_op_executed()
      eff:
        op_executed = true;
        if(k.is_eq() or k.is_op()) {
          op_stored = false;
        }
      exec:
        s.exec_op();
    }
}

class key {
  attr:
    str k = '';

  state:
    dom k_val = ('digit', 'point', 'op', 'eq', 'clear', 'erase');
    bool processed;

  init:
    key(){
      k_val = 'digit';
    }

  func:
    get_value():str { ret k;}
    set_value(str val) { k = val;}

  pred:
    is_op() {ret (k_val == 'op');}
    is_digit() {ret (k_val == 'digit');}
    is_point() {ret (k_val == 'point');}
    is_eq() {ret (k_val == 'eq');}
    is_clear() {ret (k_val == 'clear');}
    is_erase() {ret (k_val == 'erase');}

  oper:
    no_op (stack s){
      when:
        not processed and
        is_point() and
        s.is_dec_point()
      eff:
        processed = true;
    }
}

class display {
  state:
    bool updated;

  func:
    show_stack(stack s){print(s.get_value());}

  oper:
    show_stack(stack s, key k) {
      when:
        not updated and
        k.processed and
        s.changed

      eff:
        updated = true;
        s.changed = false;

      exec:
        show_stack();
    }
}
