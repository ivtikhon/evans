# Simple calculator in Evans
# Developed by Igor Tikhonin in 2019
#
# Model description:
# =================
# Calculator consists of the following parts:
# - stack,
# - arithmetic unit (ALU),
# - display,
# - keyboard.
# Operations:
# 1) when a digit or digital point button is pressed
#    its value is pushed to the stack and displayed;
# 2) when an operation button (+,-,/,*) is pressed, then:
#    operation is stored to the ALU, or, if the ALU store is not empty,
#    the early entered operation is executed the same way as if the equal sign
#    is pressed; then the current operation is stored to the ALU;
# 3) when the equal sign ('=') sign is pressed,
#    the operation stored in alu is executed, using the stack and the register values as operands,
#    and the result stored to register; the result is also copied to the stack and displayed;
#    the ALU store is cleared.


class stack { # attributes and state variables share the same namespace within class
  attr:
    list s;
  state:
    list last_key = ('digit' = default, 'point'); # 'undef' is the default value, unless specified
    bool dec_point, changed = false;
    bool tobe_cleaned; # uninitialized state variable; bool variables are initialized to false by default

  init: # there might be multiple constructors
    stack() {  # constructor has full access to all attributes
      s.append('0');
      tobe_cleaned = false  # false is the default value, i.e. initialization here is redundant
                            # last semicolon can be omitted
    }

  func:
    push_key(key k) { # functions have access to attributes, but not to the state variables
      s.append(k.get_value())
    }

    push_reg(alu a) {
      s.extend(str(a.get_reg()).split())
    }

    str getValue(){ ret ''.join(s) }

    clean(){ s.clear() }

  pred:
    is_last_key_digit(){ ret (last_key == 'digit') } # predicates have read-only access to state variables; predicates always return bool
    is_last_key_point(){ ret (last_key == 'point') }
    is_dec_point(){ ret (dec_point) }

  oper:
    push (key k) {
      precond:
        not changed and
        not k.processed and
        (k.is_digit or (k.k_val == 'point' and not dec_point))
      eff:
        changed = true;
        k.processed = true;
        if (k.is_point) {
          last_key = 'point';
          dec_point = true;
        } else {
          last_key = 'digit'
        }
      exec:
        push_key(k);
    }

    clean(key k){
      precond:
        not k.processed and
        (k.is_digit or k.is_point) and
        tobe_cleaned
      eff:
        tobe_cleaned = false;
        dec_point = false;
        last_key = 'digit';
      exec:
        clean();
    }

  oper copy_from_register(key k, alu a){
    precond:
      a.is_op_executed and
      (k.is_op or k.is_eq) and
      not k.processed
    eff:
      if (k.is_eq) {
        k.processed = True;
        changed = True;
        a.reg_stored = False;
        tobe_cleaned = True;
        a.op_executed = False
      }
    exec:
      clean();
      push_reg(a);
  }
}
