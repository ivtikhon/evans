---
# Simple calculator in Evans YAML
# Developed by Igor Tikhonin in 2018
#
# Model description:
# 1) when a digit or digital point button is pressed
#    its value is pushed to stack and displayed;
# 2) when an operation button (+,-,/,*) is pressed, then:
#    if the early entered operation value is empty
#    store the operation to the early entered operation variable;
#    else, perform operation as if '=' sign was pressed and then store the operation
#    to the early entered operation variable;
# 3) when the '=' sign is pressed,
#    execute the early entered operation with stack and register,
#    store the result to register and copy it to stack; clear
#    early entered operation

classes:
  Stack:
    attr:
      s: list
    methods:  # the actual methods should be written in some language (e.g. Python) for now;
              # after plan is created, the interpreter will generate code and then execute it;
              # later, when the Evans syntax is designed, the intermediate code generation phase won't be necessary;
      pushKey:
        parameters:
          k: Key
        body: |
          self.s.append(k.getValue())

      pushReg:
        parameters:
          a: Alu
        body: |
          self.s.extend(str(a.getReg()).split())

      getValue:
        body: |
          return ''.join(self.s)

      clean:
        body: |
          self.s.clear()
    state:
      last_key: ['digit', 'point']  # state variable with explisitly listed values (inline enum);
                                    # 'undef' is the default value for enums
                                    # TODO: think how to declare other classes variables
      dec_point: Bool # False is the default value for Bool type
      changed: Bool
      tobe_cleaned: Bool
            # types of state variables so far:
            #   - inline enum
            #   - Bool
            #   - Num (to be done)
    predicates: # predicates in Evans are equivalent to PDDL's derived predicates, i.e. read only, can't be used for assignments;
                # TODO: predicates in PDDL can have multiple arguments;
                #       in Evans this can be implemented the same way as parameters in operators
      isLastKeyDigit: last_key == 'digit' # expressions can contain comparisons '>', '<', '>=', '<=', '==', '!=',
                                          # and logical operators: not, and, or, with standard priorities, i.e not, and, or;
                                          # only simple comparisons are supported for now, e.g. var == 'key'
                                          # comparisons can't be combined with logical operators
      isLastKeyPoint: last_key == 'point'
      isDecPoint: dec_point # synonym to dec_point == True
    operators: # actions in PDDL terms
      push:
        parameters: # global variables are not supported, i.e. the variable scope is limitied
                    # by parameters and variables defined in classes;
                    # TODO: it is not clear how to implement PDDL operators 'forall' and 'exists';
                    #       think about using lists in state operators
                    # TODO: think about PDDL's 'imply'
          k: Key
        when: # condition check; state variables can be used here as well as predicates
              # lists interpreted as conjuctions (and)
          - not changed
          - not k.processed
          - k.isDigit or (k.k_val == 'point' and not dec_point)  # k.isDigit is a shortcut for k.isDigit()
                                # state variables can be tested directly, e.g. k.k_val == 'point', which is equal to k.isPoint
                                # TODO: implement full (not shortcut) predicate call with zero parameters k.isDigit()
                                #       and with multiple parameters var.predicate(param1=val1, param2=val2)
          - not tobe_cleaned
        effect: # only simple assignments are supported; one assignment per list item
          - changed: True
          - k.processed: True
          - if: k.isPoint # one condition per list item
            then:
              - last_key: 'point'
              - dec_point: True
            else:
              - last_key: 'digit'
        exec: # TODO: effect might be conditional; think about conditional execution;
              # exec section should have read access to state variables and full access to attributes
          - pushKey: k  # data methods are called from here;
                      # assignments, conditionals, loops, etc. are not supported for now;
                      # TODO: should we be able to call other classes methods here?

      clean:
        parameters:
          k: Key
        when:
          - not k.processed
          - k.isDigit or k.isPoint
          - tobe_cleaned
        effect:
          - tobe_cleaned: False
          - dec_point: False
          - last_key: 'digit'
        exec:
          - clean:  # methods can be called with no parameters

      copy_from_register:
        parameters:
          k: Key
          a: Alu
        when:
          - a.isOpExecuted
          - k.isOp or k.isEq
          - not k.processed
        effect:
          - k.processed: True
          - changed: True
          - a.reg_stored: False
          - tobe_cleaned: True
        exec:
          - clean:
          - pushReg: a

  Alu:
    attr:
      reg: float
      op: str
    methods:
      storeReg:
        parameters:
          s: Stack
        body: |
          self.reg = float(s.getValue())
      storeOp:
        parameters:
          k: Key
        body: |
          self.op = k.getValue()
      execOp:
        parameters:
          s: Stack
        body: |
          st1 = float(s.getValue())
          if self.op == '+':
            self.reg += st1
          elif self.op == '-':
            self.reg -= st1
          elif self.op == '*':
            self.reg *= st1
          elif self.op == '/':
            self.reg /= st1
    state:
      reg_stored: Bool
      op_executed: Bool
      op_stored: Bool
    predicates:
      isOpExecuted: op_executed == True
      isOpStored: op_stored == True
      isRegStored: reg_stored == True
    operators:
      stack_to_register:
        parameters:
          k: Key
          s: Stack
        when:
          - not k.processed
          - k.isOp
          - not reg_stored
          - isOpStored
        effect:
          - reg_stored: True
          - k.processed: True
          - s.tobe_cleaned: True
        exec:
          - storeReg: s

      store_op:
        parameters:
          k: Key
        when:
          - not isOpStored
          - k.isOp
          - not reg_stored
          - not k.processed
        effect:
          - op_stored: True
        exec:
          - storeOp: k

      exec_op:
        parameters:
          k: Key
          s: Stack
        when:
          - isOpStored
          - k.isOp or k.isEq
          - isRegStored
          - not k.processed
          - not isOpExecuted
        effect:
          - op_executed: True
          - if: k.isEq
            then:
              - op_stored: False
        exec:
          - execOp: s

  Key:
    attr:
      k: str
    methods:
      getValue:
        body: |
          return self.k
      setValue:
        parameters:
          val: str
        body: |
          self.k = val
    state:
      k_val: ['digit', 'point', 'op', 'eq', 'clear', 'erase']
      processed: Bool
    predicates:
      isOp: k_val == 'op'
      isDigit: k_val == 'digit'
      isPoint: k_val == 'point'
      isEq: k_val == 'eq'
      isClear: k_val == 'clear'
      isErase: k_val == 'erase'
    operators:
      no_op:
        parameters:
          s: Stack
        when:
          - not processed
          - isPoint
          - s.isDecPoint
        effect:
          - processed: True

  Display:
    state:
      updated: Bool
    operators:
      print_stack:
        parameters:
          s: Stack
          k: Key
        when:
          - not updated
          - k.processed
          - s.changed
        effect:
          - updated: True
          - s.changed: False

main:
  # main section:
  #   - main can read the list of arguments;
  #   - there should be methods to read/write from/to files (sockets, streams);
  #   - there should be some way to loop over actions;
  #   - main can trigger planning
  #   - there should be a way to dump the planning state (into json format)
  #   - variables can be defined in 'parameters' and exec 'vars'
  # exec section:
  #   - exec has 'vars' section, where variables are declared
  #   - 'tasks' section:
  #       - code: here we initialize state variables and attributes;
  #       - auto: here we run planning and execution of the obtained plan
  #       TODO: think about recovery from unsuccessfull planning
  parameters:
    input_file: str
              # parameters of main are the program attributes,
              # the format is: -input_file='file name';
  vars:
    # the purpose of the objects is to keep the object characteristics (attributes and states);
    # state variables are used for planning, and attributes are used at the execution phase
    stack1: Stack
    key1: Key
    display1: Display
    alu1: Alu
    key_val1: str #
    key_state1: str
  tasks: # one task per list element
    - loop:  # unconditional (endless) loop; TODO implement loops with conditional exit
      # code section has write access to attributes of variables defined in the vars section
      - code: |
          key_val1 = read('calc')
          key1.k = key_val1
          if key_val1.isdigit():
              key_state1 = 'digit'
          elif key_val1 == '.':
              key_state1 = 'point'
          elif key_val1 == '=':
              key_state1 = 'eq'
          elif key_val1 == 'C':
              key_state1 = 'clear'
          elif key_val1 == 'R':
              key_state1 = 'erase'
          elif key_val1 in ['+', '-', '/', '*']:
              key_state1 = 'op'
      # trigger automated actions (planning and execution of generated plan)
      - auto:
          name: 'Simple calculator'
          objects:  # here we just list the objects, participating in automatic planning;
            - stack1
            - key1
            - display1
            - alu1
          init:
            # one assignment per list item
            - key1.processed: False
            - key1.k_val: digit
            - display1.updated: False
          goal:
            - key1.processed: True
            - if: stack1.changed
              then:
                - display1.updated: True
      - break:
